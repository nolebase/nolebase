---
title: 第 13 章 事务基础知识
---

# MySQL 高级特性篇

# 第 13 章 事务基础知识

## 1. 数据库事务概述

### 1.1 存储引擎支持情况

SHOW ENGINES 命令来查看当前MySQL支持的存储引擎都有哪些，以及这些存储引擎是否支持事务。

![](https://cdn.jsdelivr.net/gh/clxmm/image@main/img/2022/03/20220315195206mysql.png)

能看出在 MySQL 中，只有InnoDB 是支持事务的。

### 1.2 基本概念

事务： 一组逻辑操作单元，使数据从一种状态变换到另一种状态。
事务处理的原则：保证所有事务都作为 **一个工作单元** 来执行，即使出现了故障，都不能改变这种执行方式。当在一个事务中执行多个操作时，要么所有的事务都被提交 `commit` ，那么这些修改就 **永久** 地保存下来；
要么数据库管理系统将 **放弃** 所作的 **所有** 修改 ，整个事务回滚 `rollback` 到最初状态。

### 1.3 事务的ACID特性

- 原子性(atomicity)：
  
  原子性是指事务是一个不可分割的工作单位，要么全部提交，要么全部失败回滚。
  即要么转账成功，要么转账失败，是不存在中间的状态。如果无法保证原子性会怎么样？
  就会出现数据不一致的情形，A账户减去100元，而B账户增加100元操作失败，系统将无故丢失100元。

- 一致性(consistency):

  根据定义，一致性是指事务执行前后，数据从一个合法性状态变换到另外一个合法性状态。
  这种状态是语义上的而不是语法上的，跟具体的业务有关。
  那什么是合法的数据状态呢?满足 预定的约束的状态就叫做合法的状态。
  通俗一点，这状态是由你自己 来定义的(比如满足现实世界中的约束)。
  满足这个状态，数据就是一致的，不满足这个状态，数据就是不一致的!如果事务中的某个操作失败了，系统就会自动撤销当前正在执行的事务，返回到事务操作 之前的状态。

- 隔离型(isolation):

  事务的隔离性是指一个事务的执行，即一个事务内部的操作及使用的数据对 并发 的 其他事务是隔离的，并发执行的各个事务之间不能互相干扰。

如果无法保证隔离性会怎么样?假设A账户有200元，B账户0元。A账户往B账户转账两次，每次金额为50 元，分别在两个事务中执行。如果无法保证隔离性，会出现下面的情形:

```sql
UPDATE accounts SET money = money - 50 WHERE NAME = 'AA';
UPDATE accounts SET money = money + 50 WHERE NAME = 'BB';
```

![](https://user-images.githubusercontent.com/92929085/181720600-9f654f9e-c269-4dac-960e-d96d3bd0ebdd.png)

- 持久性(durability):

  - 持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来的其他操作和数据库故障不应该对其有任何影响。

  持久性是通过 事务日志 来保证的。日志包括了 重做日志 和 回滚日志 。当我们通过事务对数据进行修改 的时候，首先会将数据库的变化信息记录到重做日志中，然后再对数据库中对应的行进行修改。这样做 的好处是，即使数据库系统崩溃，数据库重启后也能找到没有更新到数据库系统中的重做日志，重新执 行，从而使事务具有持久性。

### 1.4 事务的状态

我们现在知道 事务 是一个抽象的概念，它其实对应着一个或多个数据库操作，MySQL根据这些操作所执行的不同阶段把 事务 大致划分成几个状态:

- 活动的(active)

  - 事务对应的数据库操作正在执行过程中时，我们就说该事务处在 活动的 状态。

- 部分提交的(partially committed)

  - 当事务中的最后一个操作执行完成，但由于操作都在内存中执行，所造成的影响并 没有刷新到磁盘 时，我们就说该事务处在 部分提交的 状态。

- 失败的(failed)

  - 当事务处在 活动的 或者 部分提交的 状态时，可能遇到了某些错误(数据库自身的错误、操作系统 错误或者直接断电等)而无法继续执行，或者人为的停止当前事务的执行，我们就说该事务处在 失败状态

- 中止的(aborted)

  - 如果事务执行了一部分而变为 失败的 状态，那么就需要把已经修改的事务中的操作还原到事务执 行前的状态。换句话说，就是要撤销失败事务对当前数据库造成的影响。我们把这个撤销的过程称 之为 回滚 。当 回滚 操作执行完毕时，也就是数据库恢复到了执行事务之前的状态，我们就说该事 务处在了 中止的 状态。

  举例:

  ```sql
  UPDATE accounts SET money = money - 50 WHERE NAME = 'AA';
  UPDATE accounts SET money = money + 50 WHERE NAME = 'BB';
  ```

- 提交的(committed)

  当一个处在 部分提交的 状态的事务将修改过的数据都 同步到磁盘 上之后，我们就可以说该事务处

  在了  状态。

一个基本的状态转换图如下所示:

![](https://cdn.jsdelivr.net/gh/clxmm/image@main/img/2022/03/20220315195813mysql.png)

## 2. 如何使用事务

**使用事务有两种方式，分别为 显式事务 和 隐式事务 。**

### 2.1 显式事务

**步骤1: START TRANSACTION 或者 BEGIN ，作用是显式开启一个事务。**

```sql
mysql> BEGIN;
#或者
mysql> START TRANSACTION;
```

START TRANSACTION 语句相较于 BEGIN 特别之处在于，后边能跟随几个修饰符 :

- `READ ONLY`：标识当前事务是一个只读事务，也就是属于该事务的数据库操作只能读取数据，而不能修改数据。

- `READ WRITE`（默认）：标识当前事务是一个 读写事务 ，也就是属于该事务的数据库操作既可以读取数据，也可以修改数据。

- `WITH CONSISTENT SNAPSHOT`：启动一致性读。

**步骤2: 一系列事务中的操作(主要是DML，不含DDL)**

**步骤3:提交事务 或 中止事务(即回滚事务)**

```sql
 # 提交事务。当提交事务后，对数据库的修改是永久性的。 
 mysql> COMMIT;
 
```



```sql
# 回滚事务。即撤销正在进行的所有没有提交的修改 
mysql> ROLLBACK;

# 将事务回滚到某个保存点。
mysql> ROLLBACK TO [SAVEPOINT]
```

### 2.2 隐式事务

MySQL中有一个系统变量 autocommit :

```sql
SHOW VARIABLES LIKE 'autocommit'; # 默认是 ON

UPDATE account SET balance = balance - 10 WHERE id = 1 # 此时这条DML操作是一个独立的事务
UPDATE account SET balance = balance + 10 WHERE id = 2 # 此时这条DML操作是一个独立的事务
```



当然，如果我们想关闭这种 自动提交 的功能，可以使用下边两种方法之一:

 - 显式的的使用 START TRANSACTION 或者 BEGIN 语句开启一个事务。这样在本次事务提交或者回滚前会暂时关闭掉自动提交的功能。

 - 把系统变量 autocommit 的值设置为 OFF ，就像这样:

```sql
SET autocommit = OFF;
#或
SET autocommit = 0;
```

#### 如何关闭自动提交？

- 方式1：

```sql
SET autocommit = FALSE; #针对于DML操作是有效的，对DDL操作是无效的。
UPDATE account SET balance = balance - 10 WHERE id = 1;
UPDATE account SET balance = balance + 10 WHERE id = 2;
COMMIT; #或rollback;
```

- 方式2：我们在autocommit为true的情况下，使用start transaction 或begin开启事务，那么DML操作就不会自动提交数据

```sql
START TRANSACTION;
UPDATE account SET balance = balance - 10 WHERE id = 1;
UPDATE account SET balance = balance + 10 WHERE id = 2;
COMMIT; #或rollback;
```

### 2.3 隐式提交数据的情况

- 数据定义语言(Data definition language，缩写为:DDL)

- 隐式使用或修改mysql数据库中的表 alter user drop user 也会自动提交数据

- 事务控制或关于锁定的语句

  - 1 当我们在一个事务还没提交或者回滚时就又使用 START TRANSACTION 或者 BEGIN 语句开启了另一个事务时，会 隐式的提交 上一个事务。即:

    ```
    begin 
     select 
     update 
        
    -- 没有commit 再开启一个事物，会自动提交
    begin;
    
    ```

  - 2 当前的 autocommit 系统变量的值为 OFF ，我们手动把它调为 ON 时，也会 隐式的提交 前边语句所属的事务。

  - 3 使用 `LOCK TABLES`、 `UNLOCK TABLES`  等关于锁定的语句也会隐式地提交前边语句所属的事务

- 加载数据的语句

- 关于MySQL复制的一些语句

- 其它的一些语句

### 2.4 使用举例1:提交与回滚

情况1:

```sql
CREATE TABLE user(name varchar(20), PRIMARY KEY (name)) ENGINE=InnoDB;
BEGIN;
INSERT INTO user SELECT '张三'; COMMIT;
BEGIN;
INSERT INTO user SELECT '李四'; INSERT INTO user SELECT '李四'; ROLLBACK;
SELECT * FROM user;
```

**情况2:**

```sql
CREATE TABLE user (name varchar(20), PRIMARY KEY (name)) ENGINE=InnoDB;
BEGIN;
INSERT INTO user SELECT '张三'; COMMIT;
INSERT INTO user SELECT '李四'; INSERT INTO user SELECT '李四'; ROLLBACK;
```

**情况3:**

```sql
CREATE TABLE user(name varchar(255), PRIMARY KEY (name)) ENGINE=InnoDB;
SET @@completion_type = 1; BEGIN;
INSERT INTO user SELECT '张三'; COMMIT;
INSERT INTO user SELECT '李四'; INSERT INTO user SELECT '李四'; ROLLBACK;
SELECT * FROM user;
```

> 当我们设置 autocommit=0 时，不论是否采用 START TRANSACTION 或者 BEGIN 的方式来开启事 务，都需要用 COMMIT 进行提交，让事务生效，使用 ROLLBACK 对事务进行回滚。
>
> 当我们设置 autocommit=1 时，每条 SQL 语句都会自动进行提交。 不过这时，如果你采用 START TRANSACTION 或者 BEGIN 的方式来显式地开启事务，那么这个事务只有在 COMMIT 时才会生效， 在 ROLLBACK 时才会回滚。

能看到相同的 SQL 代码，只是在事务开始之前设置了 SET @ocomplet ion_type =1;，结果就和我们第一次
处理的一样，只有一个“张三”。这是为什么呢？

- completion=0，这是默认情况。当我们执行 COMMIT 的时候会提交事务，在执行下一个事务时，还需要使
  用 START TRANSACTION 或者 BEGIN 来开启。
- completion=1，这种情况下，当我们提交事务后，相当于执行了 COMMIT AND CHAIN，也就是开启
  链式事务，即当我们提交事务之后会开启一个相同隔离级别的事务。
- completion=2，这种情况下 COMMIT=COMMIT AND RELEASE ， 也就是当我们提交后，会自动与服务器断
  开连接。

### 2.5 不支持事务的引擎

```sql

#举例2：体会INNODB 和 MyISAM

CREATE TABLE test1(i INT) ENGINE = INNODB;

CREATE TABLE test2(i INT) ENGINE = MYISAM;

# 针对于innodb表
BEGIN
INSERT INTO test1 VALUES (1);
ROLLBACK;

SELECT * FROM test1;


# 针对于myisam表:不支持事务
BEGIN
INSERT INTO test2 VALUES (1);
ROLLBACK;

SELECT * FROM test2;
```

### 2.6 使用举例3:SAVEPOINT

```sql
#举例3：体会 savepoint

CREATE TABLE user3(NAME VARCHAR(15),balance DECIMAL(10,2));

BEGIN;
INSERT INTO user3(NAME,balance) VALUES('张三',1000);
COMMIT;

SELECT * FROM user3;


BEGIN;
UPDATE user3 SET balance = balance - 100 WHERE NAME = '张三';

UPDATE user3 SET balance = balance - 100 WHERE NAME = '张三';

SAVEPOINT s1;#设置保存点

UPDATE user3 SET balance = balance + 1 WHERE NAME = '张三';

ROLLBACK TO s1; #回滚到保存点


SELECT * FROM user3;

ROLLBACK; #回滚操作

SELECT * FROM user3;
```

## 3. 事务隔离级别 

MySQL是一个 客户端/服务器 架构的软件，对于同一个服务器来说，可以有若干个客户端与之连接，每 个客户端与服务器连接上之后，就可以称为一个会话( Session )。每个客户端都可以在自己的会话中 向服务器发出请求语句，一个请求语句可能是某个事务的一部分，也就是对于服务器来说可能同时处理 多个事务。事务有 隔离性 的特性，理论上在某个事务 对某个数据进行访问 时，其他事务应该进行 排

 队 ，当该事务提交之后，其他事务才可以继续访问这个数据。但是这样对**性能影响太大**既想保持事事务的隔离性，又想让服务器在处理访问同一数据的多个事务时**性能尽量高些**，那就看二者如何权衡取舍了。

### 3.1 数据准备

我们需要创建一个表:

```sql
CREATE TABLE student (
    studentno INT,
    name VARCHAR(20),
    class varchar(20),
    PRIMARY KEY (studentno)
) Engine=InnoDB CHARSET=utf8;

INSERT INTO student VALUES(1, '小谷', '1班');
```

### 3.2 数据并发问题

针对事务的隔离性和并发性，我们怎么做取舍呢?先看一下访问相同数据的事务在 不保证串行执行 (也就是执行完一个再执行另一个)的情况下可能会出现哪些问题:

**1.脏写(Dirty Write)**

对于两个事务 Session A、Session B，如果事务Session A 修改了 另一个 未提交 事务Session B 修改过 的数 据，那就意味着发生了 脏写

脏写示意图

![](https://cdn.jsdelivr.net/gh/clxmm/image@main/img/2022/03/20220316203005mysql.png)

**2. 脏读(  )**

对于两个事务 Session A、Session B，Session A 读取 了已经被 Session B 更新 但还 没有被提交 的字段。之后若 Session B 回滚 ，Session A 读取 的内容就是 临时且无效 的。

![](https://cdn.jsdelivr.net/gh/clxmm/image@main/img/2022/03/20220316203141mysql.png)

Session A和Session B各开启了一个事务，Session B中的事务先将studentno列为1的记录的name列更新 为'张三'，然后Session A中的事务再去查询这条studentno为1的记录，如果读到列name的值为'张三'，而 Session B中的事务稍后进行了回滚，那么Session A中的事务相当于读到了一个不存在的数据，这种现象 就称之为 脏读 。

**3.不可重复读(Non-Repeatable Read)**

对于两个事务Session A、Session B，Session A 读取 了一个字段，然后 Session B 更新 了该字段。 之后Session A 再次读取 同一个字段， 值就不同 了。那就意味着发生了不可重复读。

我们在Session B中提交了几个 隐式事务 (注意是隐式事务，意味着语句结束事务就提交了)，这些事务 都修改了studentno列为1的记录的列name的值，每次事务提交之后，如果Session A中的事务都可以查看 到最新的值，这种现象也被称之为 不可重复读 。

![](https://cdn.jsdelivr.net/gh/clxmm/image@main/img/2022/03/20220316203357mysql.png)

**4. 幻读( Phantom )**

对于两个事务Session A、Session B, Session A 从一个表中 读取 了一个字段, 然后 Session B 在该表中 插入 了一些新的行。 之后, 如果 Session A 再次读取 同一个表, 就会多出几行。那就意味着发生了幻读。

![](https://cdn.jsdelivr.net/gh/clxmm/image@main/img/2022/03/20220316203609mysql.png)

Session A中的事务先根据条件 studentno > 0这个条件查询表student，得到了name列值为'张三'的记录; 之后Session B中提交了一个 隐式事务 ，该事务向表student中插入了一条新记录;之后Session A中的事务 再根据相同的条件 studentno > 0查询表student，得到的结果集中包含Session B中的事务新插入的那条记 录，这种现象也被称之为 幻读 。我们把新插入的那些记录称之为 幻影记录 。

```
注意1：
有的司学会有疑问，那如果 Session B 中刪除了：
一些符合 studentno＞日的记录而不是插入新记录，那Session A
之后再根据studentno~日的条件读取的 记录变少了，这种现象算不算幻读 呢？这种现象 不属于幻读，幻读强
调的是一个事务按照某个 相同条件多次读取 记录时，后读取时读到了之前 没有读到的记录，
注意2：
那对于先前己经读到的记录，之后又读取不到这种情况，算啥呢？这相当于对每一条记录都发生了 不可重复读的
现彖。幻读只是重点强调了读取到了之前读取没有获取到的记录。
```



### 3.3 SQL中的四种隔离级别

上面介绍了几种并发事务执行过程中可能遇到的一些问题，这些问题有轻重缓急之分，我们给这些问题按照严重性来排一下序:

```
脏写 > 脏读 > 不可重复读 > 幻读
```

我们愿意舍弃一部分隔离性来换取一部分性能在这里就体现在:设立一些隔离级别，隔离级别越低，并发问题发生的就越多。 SQL标准 中设立了4个 隔离级别 :

- READ UNCOMMITTED :读未提交，在该隔离级别，所有事务都可以看到其他未提交事务的执行结 果。不能避免脏读、不可重复读、幻读。
- READ COMMITTED :读已提交，它满足了隔离的简单定义:一个事务只能看见已经提交事务所做 的改变。这是大多数数据库系统的默认隔离级别(但不是MySQL默认的)。可以避免脏读，但不可 重复读、幻读问题仍然存在。
- REPEATABLE READ :可重复读，事务A在读到一条数据之后，此时事务B对该数据进行了修改并提 交，那么事务A再读该数据，读到的还是原来的内容。可以避免脏读、不可重复读，但幻读问题仍 然存在。这是MySQL的默认隔离级别。
- SERIALIZABLE :可串行化，确保事务可以从一个表中读取相同的行。在这个事务持续期间，禁止 其他事务对该表执行插入、更新和删除操作。所有的并发问题都可以避免，但性能十分低下。能避 免脏读、不可重复读和幻读。

SQL标准 中规定，针对不同的隔离级别，并发事务可以发生不同严重程度的问题，具体情况如下:

![](https://cdn.jsdelivr.net/gh/clxmm/image@main/img/2022/03/20220316204026mysql.png)

**脏写 怎么没涉及到?因为脏写这个问题太严重了，不论是哪种隔离级别，都不允许脏写的情况发生。**

不同的隔离级别有不同的现象，并有不同的锁和并发机制，隔离级别越高，数据库的并发性能就越差，4种事务隔离级别与并发性能的关系如下:

![](https://cdn.jsdelivr.net/gh/clxmm/image@main/img/2022/03/20220316204114mysql.png)

### 3.4 MySQL支持的四种隔离级别

MySQL的默认隔离级别为REPEATABLE READ，我们可以手动修改一下事务的隔离级别。

```
# 查看隔离级别，MySQL 5.7.20的版本之前: 
mysql> SHOW VARIABLES LIKE 'tx_isolation'; 
+---------------+-----------------+
| Variable_name | Value | 
+---------------+-----------------+
| tx_isolation | REPEATABLE-READ | 
+---------------+-----------------+
1 row in set (0.00 sec)
```

```sql
# MySQL 5.7.20版本之后，引入transaction_isolation来替换tx_isolation
# 查看隔离级别，MySQL 5.7.20的版本及之后:
mysql> SHOW VARIABLES LIKE 'transaction_isolation'; 
+-----------------------+-----------------+
| Variable_name | Value | 
+-----------------------+-----------------+
| transaction_isolation | REPEATABLE-READ |
+-----------------------+-----------------+
1 row in set (0.02 sec)
```

```
#或者不同MySQL版本中都可以使用的: 
SELECT @@transaction_isolation;
```

### 3.5 如何设置事务的隔离级别

**通过下面的语句修改事务的隔离级别:**

```
SET [GLOBAL|SESSION] TRANSACTION ISOLATION LEVEL 隔离级别; #其中，隔离级别格式:
> READ UNCOMMITTED
> READ COMMITTED
> REPEATABLE READ
> SERIALIZABLE
```

或者:

```
SET [GLOBAL|SESSION] TRANSACTION_ISOLATION = '隔离级别' #其中，隔离级别格式:
> READ-UNCOMMITTED
> READ-COMMITTED
> REPEATABLE-READ
> SERIALIZABLE
```

**关于设置时使用GLOBAL或SESSION的影响:**

- 使用 GLOBAL 关键字(在全局范围影响)

  ```sql
  SET GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE; #或
  SET GLOBAL TRANSACTION_ISOLATION = 'SERIALIZABLE';
  ```

  则:

  - 当前已经存在的会话无效
  - 只对执行完该语句之后产生的会话起作用

- 使用 SESSION 关键字(在会话范围影响):

  ```sql
  SET SESSION TRANSACTION ISOLATION LEVEL SERIALIZABLE; #或
  SET SESSION TRANSACTION_ISOLATION = 'SERIALIZABLE';
  ```

  则:

  - 对当前会话的所有后续的事务有效
  - 如果在事务之间执行，则对后续的事务有效
  - 该语句可以在已经开启的事务中间执行，但不会影响当前正在执行的事务

> 数据库规定了多种事务隔离级别，不同隔离级别对应不同的干扰程度，隔离级别越高，数据一致性就越好，但并发性越弱。

### 3.6 不同隔离级别举例

## 4. 事务的常见分类

- 扁平事务(Flat Transactions)
- 带有保存点的扁平事务(Flat Transactions with Savepoints)
- 链事务(Chained Transactions)
- 嵌套事务(Nested Transactions)
- 分布式事务(Distributed Transactions)



